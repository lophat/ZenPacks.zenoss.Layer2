#######################################################################
#
# Copyright (C) 2010, Chet Luther <chet.luther@gmail.com>
#               2015, Taras Bunyk <tbunyk@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#######################################################################

import sys
import re
from pprint import pprint

from twistedsnmp.pysnmpproto import v2c, rfc1902
from twistedsnmp import datatypes

def main():
    ''' Get filename argument and print oids dictionary '''
    if len(sys.argv) >= 2:
        filename = sys.argv[1]
    else:
        print 'Pass filename or '-' for stdin'
        print 'File should be generated by snmpwalk with numeric OIDs'
        print 'Like this:'
        print 'snmpwalk -v2c -On -c $COMMUNITY_STRING $HOST $START_OID > $FILENAME'
        return
    pprint(
        parse_snmpwalkfile(filename)
    )

def parse_snmpwalkfile(filename):
    if filename == '-':
        return parse_snmpwalklines(sys.stdin.readlines())
    else:
        with open(filename, 'r') as snmpwalk:
            return parse_snmpwalklines(snmpwalk)


def parse_snmpwalklines(lines):
    ''' Returns oids values dictionary '''
    oids = {}
    oid = ''
    type_ = ''
    value = []

    for line in lines:
        line = line.rstrip()

        match = re.search(r'^([^ ]+) = ([^\:]+):\s*(.*)$', line)
        if not match:
            match = re.search(r'^([^ ]+) = (".*")$', line)

        if match:
            if len(value) > 0:
                oids[oid] = convert_oid_value(type_, value)

                oid = ''
                type_ = ''
                value = []

            groups = match.groups()
            if len(groups) == 3:
                oid, type_, value1 = groups
            else:
                oid, type_, value1 = (groups[0], 'STRING', groups[1])

            oid = sanitize_dotted(oid)

            if type_ == 'Timeticks':
                value1 = re.search(r'^\((\d+)\) .*$', value1).groups()[0]

            value.append(value1.strip('"'))
        else:
            value.append(line.strip('"'))

    if oid and type_:
        oids[oid] = convert_oid_value(type_, value)

    return oids

def tryIntConvert(myint):
    conv = -1
    try:
        conv = int(myint)
    except:
        m = re.match(".*\((?P<myint>\d+)\).*|(?P<myint2>\d+).*", myint)
        if m:
            myint2 = m.groupdict()["myint"] or m.groupdict()["myint2"]
            try:
                conv = int(myint2)
            except:
                pass
    return conv


def sanitize_dotted(string):
    '''
    Return dotted decimal strings with non-numerics replaced with 1.

    This is necessary because some snmpwalk output files have had IP
    addresses obscured with non-numeric characters.
    '''

    return re.sub(r'[^ \.\da-fA-F]', '1', string)


def fix_snmp_datatypes():
    '''
        twistedsnmp has a bug that causes it to fail to properly convert
        Counter64 values. We workaround this by retroactively
        fixing datatypes mappings.
    '''
    fixed_v2Mapping = []
    for datatype, converter in datatypes.v2Mapping:
        if datatype == v2c.Counter64:
            fixed_v2Mapping.append(
                (datatype, datatypes.SimpleConverter(v2c.Counter64)))
        else:
            fixed_v2Mapping.append((datatype, converter))

    datatypes.v2Mapping = fixed_v2Mapping

    fixed_v1Mapping = [(rfc1902.Counter64, datatypes.SimpleConverter(v2c.Counter64))]
    for datatype, converter in datatypes.v1Mapping:
        if datatype != rfc1902.Counter64:
            fixed_v1Mapping.append((datatype, converter))

    datatypes.v1Mapping = fixed_v1Mapping

def convert_oid_value(type_, value):
    if type_ == 'Counter32':
        return v2c.Counter32(tryIntConvert(value[0]))

    elif type_ == 'Counter64':
        return rfc1902.Counter64(long(value[0]))

    elif type_ == 'Gauge32':
        return v2c.Gauge32(tryIntConvert(value[0]))

    elif type_ == 'Hex-STRING':
        value = [sanitize_dotted(x) for x in value]
        return ''.join(
            [chr(int(c, 16)) for c in ' '.join(value).split(' ')])

    elif type_ == 'INTEGER':
        return tryIntConvert(value[0])

    elif type_ == 'IpAddress':
        value[0] = sanitize_dotted(value[0])
        return v2c.IpAddress(value[0])

    elif type_ == 'OID':
        return v2c.ObjectIdentifier(value[0])

    elif type_ == 'STRING':
        return '\n'.join(value)

    elif type_ == 'Timeticks':
        return v2c.TimeTicks(int(value[0]))

if __name__ == '__main__':
    main()
